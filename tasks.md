## Задача 1      
###  Создайте простой интерфейс для Drag'n'Drop, который позволяет перемещать блок на странице с помощью мыши.  
При нажатии на блок мышью и перемещении ее с зажатой кнопкой мыши, блок будет следовать за курсором мыши до тех пор, пока кнопка мыши не будет отпущена.   
При этом блок будет перемещаться таким образом, чтобы его верхний левый угол оставался на том же месте, где он находился при начале перемещения.  
  `<style>`  
      `.block {`  
        `position: absolute;`  
        `width: 100px;`  
        `height: 100px;`  
        `border: 2px solid black;`  
        `border-radius: 10px;`  
        `background-color: blueviolet;`  
        `cursor: move;`  
      `}`  
    `</style>`  
`<div class="block"></div>`  

1. В самом начале кода мы определяем переменную block, используя метод `document.querySelector('.block')`. Этот метод ищет первый элемент на странице с классом "block" и присваивает его переменной block  

2. Далее мы определяем переменные startX, startY, offsetX и offsetY, которые мы будем использовать внутри функций startDrag, drag и stopDrag.  

3. Функция `startDrag` запускается при нажатии на кнопку мыши внутри блока. Внутри этой функции мы определяем начальное положение курсора мыши, используя свойства `clientX` и `clientY` объекта event. Мы также определяем начальные координаты блока, используя свойства `offsetLeft` и `offsetTop`. Мы сохраняем эти значения в соответствующие переменные, чтобы использовать их позже при перемещении блока.  

Строки `offsetX = block.offsetLeft;` и `offsetY = block.offsetTop;` используются для сохранения начального смещения (отступа) элемента .block относительно его родительского контейнера.  

Свойство `offsetLeft` возвращает горизонтальное смещение элемента относительно его ближайшего родительского элемента, который имеет позиционирование, отличное от static. Оно измеряется в пикселях и может быть положительным или отрицательным в зависимости от положения элемента.  

Свойство `offsetTop` возвращает вертикальное смещение элемента относительно его ближайшего родительского элемента с позиционированием, отличным от static. Оно также измеряется в пикселях и может быть положительным или отрицательным.  

В данном случае, значения offsetX и offsetY сохраняют начальное смещение элемента .block относительно его родительского контейнера в момент начала перетаскивания (когда событие mousedown происходит на элементе .block). Это смещение используется позже в функции drag для определения новой позиции элемента на основе текущего положения указателя мыши и начального смещения.  

4. После того, как мы определили начальные значения, мы добавляем обработчики событий mousemove и mouseup к объекту document. Эти обработчики событий будут вызываться при перемещении мыши и отпускании кнопки мыши соответственно.  

5. Функция drag запускается каждый раз при перемещении мыши, после того, как была запущена функция startDrag. Внутри этой функции мы определяем текущее положение курсора мыши и вычисляем новые координаты для блока. Мы используем начальные координаты блока, чтобы вычислить разницу между начальным положением блока и текущим положением курсора мыши, и добавляем эту разницу к начальным координатам блока. Затем мы устанавливаем новые координаты блока, используя свойства style.left и style.top.   

6. Функция` stopDrag` запускается при отпускании кнопки мыши. Внутри этой функции мы удаляем обработчики событий mousemove и mouseup из объекта document, чтобы прекратить перемещение блока.
   
Метод `removeEventListener` используется для удаления обработчика события, который ранее был добавлен с помощью метода addEventListener. Он позволяет отключить обработку определенного типа события на указанном элементе.  

`removeEventListener` используется в функции stopDrag, чтобы отключить слушатели событий mousemove и mouseup. После вызова removeEventListener, обработчики drag и stopDrag больше не будут вызываться при соответствующих событиях.  

При удалении слушателей событий с помощью removeEventListener, важно указать те же параметры (тип события и функцию обработчика), которые были использованы при добавлении слушателя с помощью addEventListener. Это позволяет точно идентифицировать слушатель, который должен быть удален.  
Пример использования: `document.removeEventListener('mousemove', drag);`  

Таким образом, весь код работает вместе, чтобы создать возможность перемещения блока на странице с помощью мыши.  

## Задача 2      
###  Родительский блок  
Мы можем изменить задачу 1, чтобы при перемещении блока его позиция не выходила за пределы родительского контейнера.  

В этом случае мы должны определить родительский контейнер для блока, вычислить его границы и использовать их для проверки новых координат блока в функции drag.  
    `<style>`  
      `.block {`  
        `position: absolute;`  
        `width: 100px;`  
        `height: 100px;`  
        `border: 2px solid black;`  
        `border-radius: 10px;`  
        `background-color: blueviolet;`  
        `cursor: move;`  
      `}`  
      `.container {`  
        `position: relative;`  
        `width: 300px;`  
        `height: 300px;`  
        `margin: 50px auto;`  
        `border: 1px solid #ccc;`  
      `}`  
    `</style>`  
    `<div class="container">`  
      `<div class="block"></div>`  
    `</div>`  

Чтобы не допустить выхода блока за пределы контейнера, необходимо включить дополнительную проверку в обработчике события mousemove, который отвечает за перемещение блока.  
В этой проверке мы будем использовать свойства clientWidth и clientHeight контейнера, чтобы вычислить границы, в которых блок может свободно перемещаться.  
Примерный алгоритм решения будет выглядеть следующим образом:  
1. Получить ширину и высоту контейнера, в котором находится перемещаемый блок, используя свойства clientWidth и clientHeight.  
2. Получить координаты левого верхнего угла блока внутри контейнера, используя свойства offsetLeft и offsetTop.  
3. Вычислить границы, в которых блок может свободно перемещаться, используя следующие формулы:  
leftBoundary = 0  
topBoundary = 0  
rightBoundary = containerWidth - blockWidth  
bottomBoundary = containerHeight - blockHeight  
4. Вычислить новые координаты блока после перемещения, используя свойства clientX и clientY события mousemove и сохраненные координаты блока при начале перемещения.  
5. Проверить, не выходит ли блок за границы контейнера, используя вычисленные границы и новые координаты блока. Если выходит, то установить блок на соответствующую границу.  
6. Установить новые координаты блока в стилях CSS с помощью свойств style.left и style.top.  
Таким образом, блок будет оставаться внутри контейнера при перемещении мыши, а не выходить за его пределы.  


Возможное решение:  
1. Получение ссылки на блок: сначала необходимо получить ссылку на блок, который мы хотим переместить. Это можно сделать с помощью метода querySelector(), который позволяет найти элемент на странице по его селектору.  

2. Добавление обработчика события mousedown: следующим шагом является добавление обработчика события mousedown на блок. Этот обработчик будет запускаться при нажатии левой кнопки мыши на блоке.  

3. Обработка события mousedown: в обработчике события mousedown мы должны сохранить начальные координаты блока и начальные координаты мыши. Для этого можно использовать свойства offsetLeft и offsetTop блока, чтобы получить его текущие координаты, и свойства clientX и clientY события mousedown, чтобы получить координаты мыши.  

4. Добавление обработчика события mousemove: после того, как пользователь нажал на блок, мы должны добавить обработчик события mousemove на всю страницу. Этот обработчик будет запускаться при перемещении мыши внутри документа после нажатия на левую кнопку мыши.  

5. Обработка события mousemove: в обработчике события mousemove мы должны вычислить новые координаты блока на основе изменения положения мыши и сохраненных координат блока. Затем мы должны установить новые значения для свойств left и top у блока, чтобы он перемещался за курсором мыши.  

6. Удаление обработчика события mousemove: после того, как пользователь отпустил левую кнопку мыши, мы должны удалить обработчик события mousemove с документа. Это можно сделать с помощью метода removeEventListener().  
